# Development of a 3D Printing Slicer for Non-Planar Slicing Applications
**Author:** Bastian Lipka

This project involves the creation of a rudimentary 3D printing slicer intended for further development towards non-planar printing applications. The slicer processes 3D models in `.stl` format, extracts relevant geometric features, and generates G-code for 3D printing. This document outlines the slicer's methodology, usage, and technical specifications.

## Overview
This slicer functions as a foundational tool for non-planar slicing in 3D printing. It operates by slicing a 3D object represented in an `.stl` file format. Each `.stl` file encodes the object geometry using triangular facets, with vertices specified as 3D coordinates. The slicer uses layer-based slicing, where a plane intersects the 3D model at predefined intervals (based on the layer height). Scaling and transformation of the object coordinates are required since `.stl` files do not inherently use metric units. Intersections between slicing planes and triangle edges form layer paths, which are then converted to G-code instructions for the printer.

## Project Structure and Libraries
The slicer code leverages the following key modules and functions:
- **`stl_to_lines`**: Converts `.stl` triangle vertices into line segments for slicing.
- **`lines_to_points`**: Calculates intersection points of slicing planes and object lines.
- **`plane_point_pairs`**: Organizes intersection points into ordered paths for each layer.
- **`add_infill`**: Generates and integrates infill patterns based on geometric intersections.
- **`combine_parts`**: Combines wall and infill segments for each layer.
- **`points_to_gcode`**: Converts ordered paths into G-code compatible with standard 3D printers.
- **`gcode_to_file`**: Exports the generated G-code to a specified file.

## Installation and Usage
1. **Download the repository** and place your `.stl` files in the designated `stl` directory.
2. **Modify `main.py`**:
   - Update `file_path` to point to your `.stl` file.
   - Set the desired layer height, object dimensions, and printer bed offsets.
3. **Run the script**: Execute `main.py` to generate G-code, which can be reviewed in slicing software (e.g., Cura) or tested on a 3D printer.
4. **Adjust settings**: Parameters such as object dimensions, infill patterns, and layer height can be customized in `main.py`.

## Methodology and Technical Details

### Wall Generation
**Slicing Triangles**: Each triangular face of the `.stl` file is represented by three vertices $(v_1, v_2, v_3)$. Each pair of vertices defines an edge of the triangle, represented as a vector $\vec{L} = v_2 - v_1$. When a slicing plane $z = h$ intersects this edge, the intersection point $p$ satisfies:

$$
p = v_1 + t(v_2 - v_1)
$$

where

$$
t = \frac{h - v_{1z}}{v_{2z} - v_{1z}}
$$

if $v_{1z} \neq v_{2z}$. Calculating $p$ for all intersecting edges provides the layer's slice path for wall generation.

**Loop Formation**: Triangular faces that share vertices (i.e., common edges) are sequentially connected by matching endpoints of adjacent segments. This connection algorithm constructs closed-loop paths, or "islands," which are necessary for continuous extrusion paths for the walls.

### Infill Patterns
**Pattern Selection**: A cross-hatch infill is generated by creating lines parallel to the X and Y axes within each slicing plane. Given the object dimensions $L_x, L_y$, an infill line $l$ has a spacing $s$ and is represented parametrically as:

$$
l_x(t) = (x_0 + t \cdot d_x, y), \quad l_y(t) = (x, y_0 + t \cdot d_y)
$$

where $d_x$ and $d_y$ are directional vectors, and intersections between the infill lines and object boundaries are calculated.

**Intersection Ordering**: For each line, intersection points are sorted by their distance to the origin, defined by:

$$
d = \sqrt{x^2 + y^2}
$$

This ordering is critical for ensuring a consistent, continuous infill pattern. If the number of intersections is odd, this indicates potential mesh errors, as each line should have an even number of intersections within a closed object boundary.

**Pairing Algorithm**: Points along each infill line are paired based on proximity, creating a back-and-forth traversal of the fill area. Points are thus paired as $(p_1, p_2), (p_3, p_4), \ldots$, ensuring efficient material deposition and minimizing travel paths.

## Results and Limitations
This slicer can successfully convert simple 3D models into printable G-code with basic wall structures and infill patterns. It showcases essential slicing principles for further development. However, limitations exist, including:
- **Single-layer walls**: Currently, the slicer does not support multi-layer wall thicknesses.
- **Limited Infill Patterns**: Only basic cross-hatch patterns are implemented.
- **Floating Precision Errors**: Minor inaccuracies can arise due to floating-point arithmetic during point calculations, affecting path alignment.

## Future Improvements
- **Enhanced Wall Thickness**: Incorporate multi-layer wall thickness using triangular calculations and vector normals for precise offsets.
- **Expanded Infill Patterns**: Introduce varied infill options, such as concentric and honeycomb patterns, optimized for strength-to-weight ratio.
- **Z-Hop and Extrusion Control**: Implement features such as z-hop to avoid collisions and optimize extrusion for consistent material flow.
- **Top/Bottom Layer Filling**: Develop robust top and bottom filling techniques to improve model completeness.

## Conclusion
This project provides a foundational framework for non-planar 3D printing applications, outlining core slicing functionalities and illustrating critical computational techniques in 3D geometry processing.
